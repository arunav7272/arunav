
import java.util.Scanner;

public class PasswordEntropyEstimator {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("PASSWORD ENTROPY & TIME-TO-CRACK ESTIMATOR (SAFE, EDUCATIONAL)");
        System.out.println("Only use this on passwords you own. This program DOES NOT attack any system.");
        System.out.println();

        System.out.print("Enter the password to analyze: ");
        String password = sc.nextLine();

        System.out.print("Enter guesses per second (e.g. 1000, 1000000): ");
        long guessesPerSecond = 0;
        try {
            guessesPerSecond = Long.parseLong(sc.nextLine().trim());
            if (guessesPerSecond <= 0) throw new NumberFormatException();
        } catch (NumberFormatException e) {
            System.out.println("Invalid number. Using default 1,000,000 guesses/sec.");
            guessesPerSecond = 1_000_000L;
        }

        AnalysisResult res = analyzePassword(password, guessesPerSecond);

        System.out.println();
        System.out.println("---- Analysis Result ----");
        System.out.println("Password length: " + password.length());
        System.out.println("Estimated character set size used: " + res.charsetSize);
        System.out.printf("Entropy: %.2f bits%n", res.entropyBits);
        System.out.println("Total possible combinations (approx): 2^" + String.format("%.2f", res.entropyBits));
        System.out.println("Guesses/second assumed: " + String.format("%,d", guessesPerSecond));
        System.out.printf("Estimated time to try all combinations: %s (full keyspace)%n", formatSeconds(res.secondsToCrackAll));
        System.out.printf("Estimated time to reach 50%% of keyspace (average crack time): %s%n", formatSeconds(res.secondsToCrackHalf));
        System.out.println();
        System.out.println("Advice:");
        System.out.println("- Increase length first: length has the biggest effect on entropy.");
        System.out.println("- Use a mix of lowercase, uppercase, digits and symbols to increase charset.");
        System.out.println("- Use a password manager to store long random passwords (high entropy).");
        System.out.println("- For online accounts, rely on multi-factor authentication (MFA) and server-side protections (rate-limiting, hashing & salting).");

        sc.close();
    }

    static class AnalysisResult {
        int charsetSize;
        double entropyBits;
        double secondsToCrackAll;
        double secondsToCrackHalf;
    }

    static AnalysisResult analyzePassword(String password, long guessesPerSecond) {
        boolean hasLower = false, hasUpper = false, hasDigit = false, hasSymbol = false;
        for (char c : password.toCharArray()) {
            if (Character.isLowerCase(c)) hasLower = true;
            else if (Character.isUpperCase(c)) hasUpper = true;
            else if (Character.isDigit(c)) hasDigit = true;
            else hasSymbol = true;
        }

        int charsetSize = 0;
        if (hasLower) charsetSize += 26;
        if (hasUpper) charsetSize += 26;
        if (hasDigit) charsetSize += 10;
        if (hasSymbol) charsetSize += 32; // approximate common symbol count

        // Fallback: if none matched (shouldn't happen), assume lowercase
        if (charsetSize == 0) charsetSize = 26;

        int length = password.length();

        // entropy in bits = length * log2(charsetSize)
        double entropyBits = length * (Math.log(charsetSize) / Math.log(2));

        // total combinations = charsetSize^length = 2^entropyBits
        // time to try all combinations (seconds) = total / guessesPerSecond = 2^entropyBits / guessesPerSecond
        double secondsToCrackAll = Math.pow(2.0, entropyBits) / (double) guessesPerSecond;

        // average time (50% of keyspace)
        double secondsToCrackHalf = secondsToCrackAll / 2.0;

        AnalysisResult res = new AnalysisResult();
        res.charsetSize = charsetSize;
        res.entropyBits = entropyBits;
        res.secondsToCrackAll = secondsToCrackAll;
        res.secondsToCrackHalf = secondsToCrackHalf;
        return res;
    }

    // Nicely format seconds into human readable form
    static String formatSeconds(double seconds) {
        if (Double.isInfinite(seconds) || Double.isNaN(seconds)) return "unbounded/too-large to compute";
        long sec = (long) Math.round(seconds);
        if (sec < 60) return sec + " seconds";
        long minutes = sec / 60; sec %= 60;
        if (minutes < 60) return String.format("%d minutes, %d seconds", minutes, sec);
        long hours = minutes / 60; minutes %= 60;
        if (hours < 24) return String.format("%d hours, %d minutes", hours, minutes);
        long days = hours / 24; hours %= 24;
        if (days < 365) return String.format("%d days, %d hours", days, hours);
        long years = days / 365; days %= 365;
        if (years < 1000) return String.format("%d years, %d days", years, days);
        // very large -> express in scientific years
        double approxYears = seconds / (3600.0 * 24.0 * 365.0);
        return String.format("%.2e years", approxYears);
    }
}
